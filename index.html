<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>QR Tracker</title>

<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Poppins", sans-serif;
}

html, body {
  max-width: 100%;
  overflow-x: hidden;
  touch-action: manipulation;
}

body {
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background: url('https://raw.githubusercontent.com/socialinfi321-svgph/QR-SCANNER-/main/WhatsApp%20Image%202025-11-10%20at%2017.46.29_9a143304.jpg') center center / contain no-repeat fixed;
  background-color: #000;
  overflow: hidden;
}

.app {
  width: 90%;
  max-width: 380px;
  height: 90vh;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
  padding: 15px 10px;
  position: relative;
  transform-origin: center center;
}

/* QR Box */
/* shifted 8px down from previous (75 -> 83) */
.qr-box {
  position: relative;
  width: 260px;
  height: 260px;
  border-radius: 20px;
  overflow: visible;
  margin: 83px auto 0 auto; /* 75 + 8px */
  display: flex;
  justify-content: center;
  align-items: center;
  background: transparent;
  transform-origin: center center;
}

/* Continuous glowing border line */
.qr-box::before {
  content: "";
  position: absolute;
  inset: -3px;
  border-radius: 20px;
  background: linear-gradient(90deg, #4285f4, #ea4335, #fbbc05, #34a853, #4285f4);
  background-size: 300% 300%;
  animation: moveBorder 3s linear infinite;
  z-index: 0;
  padding: 3px;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  box-shadow: 0 0 15px rgba(255,255,255,0.5);
}

@keyframes moveBorder {
  0% { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}

/* Soft outer glow */
.qr-box::after {
  content: "";
  position: absolute;
  inset: -10px;
  border-radius: 25px;
  background: conic-gradient(
    from 0deg,
    #4285f4,
    #ea4335,
    #fbbc05,
    #34a853,
    #4285f4
  );
  filter: blur(20px);
  opacity: 0.6;
  animation: glowSpin 6s linear infinite;
  z-index: 0;
}

@keyframes glowSpin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* QR Images */
.qr-box img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  position: absolute;
  border-radius: 20px;
  z-index: 2;
  opacity: 0;
  transform: translateX(100%);
  transition: opacity 0.3s, transform 0.3s;
  will-change: transform, opacity;
  touch-action: manipulation;
  user-select: none;
}

.qr-box img.active {
  opacity: 1;
  transform: translateX(0);
}

.qr-box img.completed {
  display: none;
}

/* smoother animation - no page zoom */
@keyframes slideOutToBox {
  0% {opacity: 1; transform: translate(0,0) scale(1);}
  100% {opacity: 1; transform: translate(-40px, 60px) scale(0.25);}
}

@keyframes slideInFromRight {
  0% {opacity: 1; transform: translateX(100%);}
  100% {opacity: 1; transform: translateX(0);}
}

@keyframes restoreFromBox {
  0% {opacity: 1; transform: translate(-40px, 60px) scale(0.25);}
  100% {opacity: 1; transform: translate(0,0) scale(1);}
}

.qr-box img.slide-out {
  animation: slideOutToBox 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}
.qr-box img.slide-in {
  animation: slideInFromRight 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}
.qr-box img.restore {
  animation: restoreFromBox 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  display: block !important;
}

/* Done text */
.qr-box .done-text {
  position: absolute;
  font-size: 22px;
  font-weight: 700;
  text-transform: uppercase;
  background: linear-gradient(90deg, #34a853, #fbbc05, #ea4335, #4285f4);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: gradientMove 3s linear infinite;
  z-index: 5;
}

@keyframes gradientMove {
  0% { background-position: 0%; }
  100% { background-position: 100%; }
}

/* Dots */
.dots {
  display: flex;
  justify-content: center;
  margin-top: 8px;
  gap: 8px;
  position: relative;
}

.dots span {
  width: 10px;
  height: 10px;
  background: #fff;
  border-radius: 50%;
  transition: background 0.3s;
  cursor: pointer;
}

.dots .active {
  background: #000;
  transform: scale(1.3);
}

/* Counter + Message */
.counter {
  color: white;
  font-size: 14px;
  margin-top: 10px;
  font-weight: 500;
  text-align: center;
}

.complete {
  text-align: center;
  color: #0f9d58;
  font-weight: 700;
  font-size: 13px;
  margin-top: 5px;
}

/* +1 Button */
.plus-btn {
  margin: 28px auto 0 auto;
  padding: 10px 30px;
  border: none;
  border-radius: 12px;
  color: white;
  background: linear-gradient(90deg, #4285f4, #ea4335, #fbbc05, #34a853);
  background-size: 400%;
  animation: gradientMove 6s infinite linear;
  font-size: 16px;
  font-weight: 600;
  display: block;
  cursor: pointer;
}

/* Bottom section */
.bottom {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  padding: 0 10px;
  position: relative;
  margin-bottom: 60px;
}

/* updated completed-box to allow multiple thumbnails */
.completed-box {
  width: 78px;
  height: 60px;
  border-radius: 10px;
  background: rgba(255,255,255,0.06);
  overflow: visible;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  position: relative;
  cursor: pointer;
  transition: transform 0.2s;
  padding-left: 6px;
}

/* container for multiple small thumbs */
.completed-box .thumb {
  width: 48px;
  height: 48px;
  border-radius: 8px;
  object-fit: cover;
  position: absolute;
  top: 6px;
  left: 6px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  transition: transform 0.2s, opacity 0.2s;
  cursor: pointer;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.06);
  user-select: none;
}

.completed-box .thumb.hidden { opacity: 0; pointer-events: none; }

.completed-box:hover {
  transform: scale(1.03);
}

.change-btn {
  background: #f44336;
  border: none;
  color: white;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  display: flex;
  justify-content: center;
  align-items: center;
  margin-left: 8px;
  cursor: pointer;
}

.next-btn {
  background: #1a73e8;
  border: none;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  color: white;
  font-size: 22px;
  cursor: pointer;
  box-shadow: 0 5px 10px rgba(0,0,0,0.2);
}
</style>
</head>

<body>
<div class="app">
  <div>
    <div class="qr-box" id="qrBox">
      <img src="https://raw.githubusercontent.com/socialinfi321-svgph/QR-SCANNER-/main/WhatsApp%20Image%202025-11-10%20at%2017.46.29_b6c5c5c4.jpg" class="active" alt="QR 1" data-index="0" draggable="false">
      <img src="https://raw.githubusercontent.com/socialinfi321-svgph/QR-SCANNER-/main/WhatsApp%20Image%202025-11-10%20at%2017.46.30_6098032b.jpg" alt="QR 2" data-index="1" draggable="false">
      <img src="https://raw.githubusercontent.com/socialinfi321-svgph/QR-SCANNER-/main/WhatsApp%20Image%202025-11-10%20at%2017.46.31_1a42bf05.jpg" alt="QR 3" data-index="2" draggable="false">
      <img src="https://raw.githubusercontent.com/socialinfi321-svgph/QR-SCANNER-/main/WhatsApp%20Image%202025-11-10%20at%2017.46.31_fa882b2d.jpg" alt="QR 4" data-index="3" draggable="false">
      <img src="https://raw.githubusercontent.com/socialinfi321-svgph/QR-SCANNER-/main/IMG_20251103_172517.png" alt="QR 5" data-index="4" draggable="false">
      <!-- done-text overlay (hidden normally) -->
      <div class="done-text" id="doneText" style="display:none;">âœ… COMPLETED</div>
    </div>

    <div class="dots" id="dots">
      <span class="active"></span><span></span><span></span><span></span><span></span>
    </div>

    <div class="counter" id="counter">0 / 8</div>
    <div class="complete" id="completeMsg"></div>
    <button class="plus-btn" id="plusBtn">+1</button>
  </div>

  <div class="bottom">
    <div style="display:flex; align-items:center;">
      <div class="completed-box" id="completedBox" title="Click to restore last completed (LIFO)"></div>
      <button class="change-btn" id="resetBtn" title="Reset">&#8635;</button>
    </div>
    <button class="next-btn" id="nextBtn">&#9654;</button>
  </div>
</div>

<script>
/*
  Updated QR Tracker JS
  - localStorage persistence (state saved on every change)
  - completedQRs is a stack (LIFO). completedBox shows multiple thumbnails.
  - restoring: clicking completedBox pops last completed and restores it to main QR box.
  - sending back to completed box: dblclick (desktop) or double-tap (mobile) on active QR OR swipe-right gesture will send the active QR back to completed box (if its count >= target).
  - Reset properly resets images, counts, completed stack and clears localStorage.
  - QR box moved 8px down in CSS.
*/

const STORAGE_KEY = 'qrTrackerState_v1';

let qrImages = Array.from(document.querySelectorAll('.qr-box img'));
let dots = Array.from(document.querySelectorAll('#dots span'));
let counter = document.getElementById('counter');
let completeMsg = document.getElementById('completeMsg');
let plusBtn = document.getElementById('plusBtn');
let nextBtn = document.getElementById('nextBtn');
let completedBox = document.getElementById('completedBox');
let resetBtn = document.getElementById('resetBtn');
let qrBox = document.getElementById('qrBox');
let doneText = document.getElementById('doneText');

const targets = [8, 8, 8, 8, 4];
let counts = [0, 0, 0, 0, 0];
// completedQRs will be an array used as a stack: last completed is last element
let completedQRs = [];
let currentQR = 0;

// touch/double-tap helpers
let lastTap = 0;
let touchStartX = null;
let touchStartY = null;

function saveState() {
  const state = {
    counts,
    completedQRs,
    currentQR,
    timestamp: Date.now()
  };
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (e) {
    console.warn('localStorage set failed', e);
  }
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;
    const state = JSON.parse(raw);
    if (state && state.counts && Array.isArray(state.counts)) {
      counts = state.counts;
      completedQRs = Array.isArray(state.completedQRs) ? state.completedQRs : [];
      currentQR = (typeof state.currentQR === 'number') ? state.currentQR : 0;
      return true;
    }
  } catch (e) {
    console.warn('localStorage load failed', e);
  }
  return false;
}

function clearCompletedBoxUI() {
  completedBox.innerHTML = '';
}

// Render completed thumbnails in order (older bottom, newer on top)
function renderCompletedBox() {
  clearCompletedBoxUI();
  // We will place thumbnails offset horizontally so multiple are visible
  completedQRs.forEach((idx, stackIndex) => {
    const thumb = qrImages[idx].cloneNode(true);
    thumb.classList.remove('active','slide-in','slide-out','restore','completed');
    thumb.classList.add('thumb');
    // compute left offset based on stackIndex (older items further left)
    const leftOffset = Math.max(6, stackIndex * 8 + 6);
    thumb.style.left = leftOffset + 'px';
    // attach data
    thumb.dataset.originalIndex = idx;
    // clicking a specific thumb will restore that specific QR (but maintain LIFO behavior if it's last)
    thumb.addEventListener('click', (e) => {
      e.stopPropagation();
      // If user clicked specifically on a thumb, restore that one.
      restoreCompleted(idx, /*specific*/ true);
    });
    completedBox.appendChild(thumb);
  });
}

function updateQRUI() {
  // hide all active classes and show correct one unless completed
  qrImages.forEach((img, i) => {
    img.classList.remove('active','slide-in','slide-out','restore');
    // hide if completed
    if (completedQRs.includes(i)) {
      img.classList.add('completed');
      img.style.opacity = '0';
      img.style.transform = 'translateX(100%)';
    } else {
      img.classList.remove('completed');
      // if it's the current QR â€” make active
      if (i === currentQR) {
        img.classList.add('active');
        img.style.opacity = '1';
        img.style.transform = 'translateX(0)';
      } else {
        img.classList.remove('active');
        img.style.opacity = '0';
        img.style.transform = 'translateX(100%)';
      }
    }
  });

  dots.forEach((dot, i) => dot.classList.toggle('active', i === currentQR && !completedQRs.includes(i)));
  counter.textContent = `${counts[currentQR]} / ${targets[currentQR]}`;
  completeMsg.textContent = counts[currentQR] >= targets[currentQR] ? "ðŸŽ¯ Target Complete!" : "";
  // if all completed, show doneText overlay
  if (completedQRs.length === qrImages.length) {
    doneText.style.display = 'block';
  } else {
    doneText.style.display = 'none';
  }

  renderCompletedBox();
  saveState();
}

function findNextAvailableQR() {
  for (let i = 1; i <= qrImages.length; i++) {
    const nextIndex = (currentQR + i) % qrImages.length;
    if (!completedQRs.includes(nextIndex)) return nextIndex;
  }
  return currentQR;
}

function markCompleted(idx) {
  if (completedQRs.includes(idx)) return; // already completed
  completedQRs.push(idx); // LIFO
  // hide image by adding completed class
  qrImages[idx].classList.add('completed');
  // ensure it's not active
  qrImages[idx].classList.remove('active');
  // add thumbnail is handled in renderCompletedBox
  // choose next available as active
  const next = findNextAvailableQR();
  if (next !== idx) {
    qrImages[next].classList.add('active');
    currentQR = next;
  } else {
    // all done -> show doneText
    currentQR = idx;
  }
  updateQRUI();
}

function restoreCompleted(indexToRestore, specific=false) {
  // If indexToRestore not in completedQRs, ignore
  if (!completedQRs.includes(indexToRestore)) return;
  // If restoring specific but it's not last, remove it from stack where it sits
  if (specific) {
    // remove the specific index from array
    completedQRs = completedQRs.filter(i => i !== indexToRestore);
  } else {
    // pop last one
    const popped = completedQRs.pop();
    // ensure popped equals indexToRestore (if called without arg)
  }
  // unmark completed
  qrImages[indexToRestore].classList.remove('completed');
  // animate restore
  qrImages[indexToRestore].classList.add('restore');
  // remove active from current and set active to restored
  qrImages.forEach(img => img.classList.remove('active'));
  setTimeout(() => {
    qrImages[indexToRestore].classList.remove('restore');
    qrImages[indexToRestore].classList.add('active');
    currentQR = indexToRestore;
    updateQRUI();
  }, 600);
}

function sendActiveBackToCompleted(byGesture=false) {
  // Only send back if active qr is completed by count (counts >= target)
  if (counts[currentQR] >= targets[currentQR]) {
    if (!completedQRs.includes(currentQR)) {
      // animate slide out
      const img = qrImages[currentQR];
      img.classList.add('slide-out');
      setTimeout(() => {
        img.classList.remove('slide-out');
        markCompleted(currentQR);
      }, 600);
    }
  } else {
    // not eligible to send back; show a small feedback
    completeMsg.textContent = "â—Target not complete yet";
    setTimeout(()=>{ if(counts[currentQR] < targets[currentQR]) completeMsg.textContent = ""; }, 900);
  }
}

/* Event listeners */

// +1 button
plusBtn.addEventListener('click', () => {
  if (counts[currentQR] < targets[currentQR]) {
    counts[currentQR]++;
    updateQRUI();
    if (counts[currentQR] === targets[currentQR]) {
      // complete it
      // small animation & then move to completed stack
      completeMsg.textContent = "ðŸŽ¯ Target Complete!";
      // mark completed with animation
      const currentImg = qrImages[currentQR];
      // slide-out and hide
      currentImg.classList.add('slide-out');
      setTimeout(() => {
        currentImg.classList.remove('slide-out');
        markCompleted(currentQR);
      }, 600);
    }
  }
});

// Completed box click (restores last completed â€” LIFO)
completedBox.addEventListener('click', (e) => {
  e.stopPropagation();
  if (completedQRs.length === 0) return;
  const lastIndex = completedQRs[completedQRs.length - 1];
  restoreCompleted(lastIndex, /*specific*/ false);
});

// Next button
nextBtn.addEventListener('click', () => {
  let nextQR = findNextAvailableQR();
  if (nextQR !== currentQR) {
    // move visuals
    qrImages[currentQR].classList.remove('active');
    qrImages[nextQR].classList.add('active');
    currentQR = nextQR;
    updateQRUI();
  }
});

// Dots click
dots.forEach((dot, i) => {
  dot.addEventListener('click', () => {
    if (!completedQRs.includes(i)) {
      qrImages[currentQR].classList.remove('active');
      currentQR = i;
      qrImages[currentQR].classList.add('active');
      updateQRUI();
    }
  });
});

// Reset button â€” full reset (clear storage)
resetBtn.addEventListener('click', () => {
  counts = new Array(qrImages.length).fill(0);
  completedQRs = [];
  currentQR = 0;
  // reset image classes and transforms
  qrImages.forEach((img, idx) => {
    img.classList.remove('active','completed','slide-out','slide-in','restore');
    img.style.opacity = idx === 0 ? '1' : '0';
    img.style.transform = idx === 0 ? 'translateX(0)' : 'translateX(100%)';
  });
  qrImages[0].classList.add('active');
  clearCompletedBoxUI();
  try { localStorage.removeItem(STORAGE_KEY); } catch(e){}
  updateQRUI();
  completeMsg.textContent = "ðŸ”„ Data Reset!";
  setTimeout(() => (completeMsg.textContent = ""), 1500);
});

// QR image interactions for gestures/dblclick/double-tap
qrImages.forEach((img, idx) => {
  // desktop double-click
  img.addEventListener('dblclick', (e) => {
    e.stopPropagation();
    // only send to completed if target reached
    sendActiveBackToCompleted(true);
  });

  // click (single) could be used later; here we use single click to focus
  img.addEventListener('click', (e) => {
    e.stopPropagation();
    // set this as current (if not completed)
    if (!completedQRs.includes(idx)) {
      qrImages[currentQR].classList.remove('active');
      currentQR = idx;
      qrImages[currentQR].classList.add('active');
      updateQRUI();
    } else {
      // if user clicks a completed image in QR area (shouldn't happen normally), try restore
      if (completedQRs.includes(idx)) {
        restoreCompleted(idx, true);
      }
    }
  });

  // touch events for mobile: detect double-tap and swipe-right
  img.addEventListener('touchstart', (ev) => {
    if (ev.touches && ev.touches[0]) {
      touchStartX = ev.touches[0].clientX;
      touchStartY = ev.touches[0].clientY;
    }
  }, {passive: true});

  img.addEventListener('touchend', (ev) => {
    const now = Date.now();
    const tapLen = now - lastTap;
    lastTap = now;
    // double-tap detection (<= 300ms)
    if (tapLen <= 300) {
      // double-tap -> send back if eligible
      sendActiveBackToCompleted(true);
      return;
    }
    // swipe detection
    if (ev.changedTouches && ev.changedTouches[0]) {
      const dx = ev.changedTouches[0].clientX - (touchStartX || 0);
      const dy = ev.changedTouches[0].clientY - (touchStartY || 0);
      if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {
        if (dx > 0) {
          // swipe right -> send back
          sendActiveBackToCompleted(true);
          return;
        }
      }
    }
    // single tap -> set current if not completed
    if (!completedQRs.includes(idx)) {
      qrImages[currentQR].classList.remove('active');
      currentQR = idx;
      qrImages[currentQR].classList.add('active');
      updateQRUI();
    }
  }, {passive: true});
});

// Prevent images from being dragged
qrImages.forEach(img => {
  img.addEventListener('dragstart', (e) => e.preventDefault());
});

// On load: restore from storage if exists
(function init() {
  const had = loadState();
  if (had) {
    // apply completed classes and active
    // ensure arrays lengths match images
    if (!Array.isArray(counts) || counts.length !== qrImages.length) {
      counts = new Array(qrImages.length).fill(0);
    }
    // clamp completedQRs values
    completedQRs = completedQRs.filter(i => Number.isInteger(i) && i >= 0 && i < qrImages.length);
    if (typeof currentQR !== 'number' || currentQR < 0 || currentQR >= qrImages.length) currentQR = 0;

    // ensure any completed images hidden
    qrImages.forEach((img,i) => {
      img.classList.remove('active','completed');
      if (completedQRs.includes(i)) {
        img.classList.add('completed');
        img.style.opacity = '0';
        img.style.transform = 'translateX(100%)';
      } else {
        img.style.opacity = '0';
        img.style.transform = 'translateX(100%)';
      }
    });
    // ensure the current QR is not a completed one; if it is, pick next available
    if (completedQRs.includes(currentQR)) {
      const nxt = findNextAvailableQR();
      currentQR = nxt;
    }
    // set active image
    qrImages[currentQR].classList.add('active');
    qrImages[currentQR].style.opacity = '1';
    qrImages[currentQR].style.transform = 'translateX(0)';
  } else {
    // fresh start
    counts = new Array(qrImages.length).fill(0);
    completedQRs = [];
    currentQR = 0;
    qrImages.forEach((img, i) => {
      img.classList.remove('active','completed','slide-in','slide-out','restore');
      img.style.opacity = i === 0 ? '1' : '0';
      img.style.transform = i === 0 ? 'translateX(0)' : 'translateX(100%)';
    });
    qrImages[0].classList.add('active');
  }
  updateQRUI();
})();

</script>
</body>
</html>
